pipeline {
  agent any

  environment {
    // ===== Config base/oculta =====
    PAIS                = 'PE'
    DB_SERVICE_PROVIDER = 'GCP - Cloud SQL'
    DB_ENGINE           = 'SQL Server'
    DB_TIME_ZONE        = 'GMT-5'
    DB_RESOURCE_LABELS  = 'test'
    DB_TAGS             = 'test'

    // Credenciales plataforma / admin
    DB_PLATFORM_USER   = 'equipo_plataforma'
    DB_PLATFORM_PASS   = 'password'
    DB_USER_ADMIN      = 'sqlserver'
    DB_PASSWORD_ADMIN  = 'password'

    // Jira / Teams
    JIRA_API_URL     = 'https://bancoripley1.atlassian.net/rest/api/3/issue/'
    TEAMS_WEBHOOK    = 'https://accenture.webhook.office.com/webhookb2/8fb63984-6f5f-4c2a-a6d3-b4fce2feb8ee@e0793d39-0939-496d-b129-198edd916feb/IncomingWebhook/334818fae3a84ae484512967d1d3f4f1/b08cc148-e951-496b-9f46-3f7e35f79570/V27mobtZgWmAzxIvjHCY5CMAFKPZptkEnQbT5z7X84QNQ1'
    PROYECT_JIRA     = 'AJI'
    TITULO_JIRA      = 'Creación de Instancia base de datos SQL Server'
    ID_ISSUETYPE_JIRA = '14898'

    // Reintentos
    MAX_RETRIES = 2

    // Valor efectivo de backup (se define en Validación de variables)
    BACKUP_EFFECTIVE = ''
  }

  options {
    timeout(time: 2, unit: 'HOURS')
    timestamps()
    buildDiscarder(logRotator(numToKeepStr: '15'))
    disableConcurrentBuilds()
  }

  parameters {
    // ===== GCP =====
    string(name: 'PROJECT_ID', defaultValue: '', description: 'ID del proyecto')
    string(name: 'REGION',     defaultValue: '', description: 'Región')
    string(name: 'ZONE',       defaultValue: '', description: 'Zona')
    choice(name: 'ENVIRONMENT', choices: ['Desarrollo', 'Pre-productivo (PP)', 'Produccion'], description: 'Ambiente')

    // ===== TYPE / INSTANCIA =====
    string(name: 'DB_INSTANCE_NAME', defaultValue: '', description: 'Nombre instancia')
    string(name: 'DB_INSTANCE_ID',   defaultValue: '', description: 'ID instancia')
    choice(name: 'DB_AVAILABILITY_TYPE', choices: ['Regional', 'Zonal'], description: 'Disponibilidad')
    choice(name: 'DB_VERSION', choices: ['SQL Server 2022', 'SQL Server 2019', 'SQL Server 2017'], description: 'Versión SQL Server')
    choice(name: 'MACHINE_TYPE', choices: ['db-custom-4-16384', 'db-custom-8-32768', 'standard'], description: 'Tipo de máquina')
    string(name: 'DB_MAX_CONNECTIONS', defaultValue: '', description: 'Máx conexiones')
    string(name: 'DB_STORAGE_SIZE', defaultValue: '', description: 'Almacenamiento (GB)')
    choice(name: 'DB_STORAGE_AUTO_RESIZE', choices: ['false', 'true'], description: 'Auto-resize')
    choice(name: 'DB_STORAGE_TYPE', choices: ['SSD', 'HDD'], description: 'Tipo de disco')
    string(name: 'DB_USERNAME', defaultValue: 'sa', description: 'Usuario DB (SQL Server)')
    string(name: 'DB_PASSWORD', defaultValue: 'password', description: 'Password DB')
    choice(name: 'DB_SQL_SERVER_LICENSE_MODEL', choices: ['PAYG', 'BRING_YOUR_OWN_LICENSE'], description: 'Modelo de licenciamiento SQL Server')
    choice(name: 'ENABLE_CACHE', choices: ['false', 'true'], description: 'Habilitar caché (por defecto false)')

    // ===== REDES =====
    string(name: 'DB_VPC_NETWORK', defaultValue: '', description: 'VPC')
    string(name: 'DB_SUBNET',      defaultValue: '', description: 'Subred')
    choice(name: 'DB_PUBLIC_ACCESS_ENABLED', choices: ['false', 'true'], description: 'Acceso público')
    choice(name: 'DB_PRIVATE_IP_ENABLED',    choices: ['true', 'false'], description: 'IP privada')
    choice(name: 'DB_IP_RANGE_ALLOWED',      choices: ['false', 'true'], description: 'Rangos permitidos (CIDR)')
    choice(name: 'DB_SSL_ENABLED',           choices: ['true', 'false'], description: 'SSL')

    // ===== SEGURIDAD / OPERACIÓN =====
    choice(name: 'DB_BACKUP_ENABLED', choices: ['true', 'false'], description: 'Backup (Obligatorio en Prod)')
    string(name: 'DB_BACKUP_START_TIME',      defaultValue: '', description: 'Hora inicio backup (HH:MM)')
    string(name: 'DB_BACKUP_RETENTION_DAYS',  defaultValue: '', description: 'Retención (días)')
    string(name: 'DB_MAINTENANCE_WINDOW_DAY', defaultValue: '', description: 'Día mantención')
    string(name: 'DB_MAINTENANCE_WINDOW_HOUR',defaultValue: '', description: 'Hora mantención')
    choice(name: 'DB_MONITORING_ENABLED', choices: ['true', 'false'], description: 'Monitoring')
    choice(name: 'DB_AUDIT_LOGS_ENABLED', choices: ['true', 'false'], description: 'Audit logs')
    choice(name: 'CREDENTIAL_FILE', choices: ['sa-plataforma', 'sa-transacciones'], description: 'Credenciales (JSON)')
    string(name: 'DB_IAM_ROLE', defaultValue: '', description: 'IAM Role')
    choice(name: 'DB_DELETION_PROTECTION', choices: ['true', 'false'], description: 'Protección borrado')
    choice(name: 'CHECK_DELETE', choices: ['true', 'false'], description: 'Check delete')
    choice(name: 'DB_ENCRYPTION_ENABLED', choices: ['true', 'false'], description: 'Encripción')

    // ===== RÉPLICA / FAILOVER =====
    choice(name: 'DB_FAILOVER_REPLICA_ENABLED', choices: ['false', 'true'], description: 'Failover replica')
    choice(name: 'DB_READ_REPLICA_ENABLED',     choices: ['false', 'true'], description: 'Read replica')

    // ===== JIRA =====
    string(name: 'TICKET_JIRA', defaultValue: 'AJI-83', description: 'Ticket de Jira')
  }

  stages {

    // 1) Validar y transicionar ticket jira
    stage('Validar y Transicionar Ticket Jira') {
      steps {
        script {
          withCredentials([usernamePassword(credentialsId: 'JIRA_TOKEN', usernameVariable: 'JIRA_USER', passwordVariable: 'JIRA_API_TOKEN')]) {
            echo "Consultando estado actual del ticket ${params.TICKET_JIRA}..."
            def estado = sh(
              script: """bash -c ' curl -s -u "$JIRA_USER:$JIRA_API_TOKEN" \
                -X GET "${JIRA_API_URL}${params.TICKET_JIRA}" \
                -H "Accept: application/json" | jq -r ".fields.status.name // \\"Desconocido\\"" '""",
              returnStdout: true
            ).trim()
            echo "Estado actual: ${estado}"

            // IDs de transición según tu flujo (ajusta si cambia)
            def transiciones = ["Tareas por hacer": "31"] // a Done

            env.ESTADO_TICKET = estado

            if (estado == "Tareas por hacer") {
              def transitionId = transiciones[estado]
              echo "Transicionando ticket ${params.TICKET_JIRA} a 'Done'..."
              def payloadTrans = groovy.json.JsonOutput.toJson([transition: [id: transitionId]])
              writeFile file: 'transicion.json', text: payloadTrans
              sh """curl -s -u "$JIRA_USER:$JIRA_API_TOKEN" -X POST -H "Content-Type: application/json" --data @transicion.json "${JIRA_API_URL}${params.TICKET_JIRA}/transitions" """

              def mensajeJira = "El ticket ${params.TICKET_JIRA} fue cerrado automáticamente por ejecución del pipeline."
              def comentario = groovy.json.JsonOutput.toJson([
                body: [type: "doc", version: 1, content: [[type: "paragraph", content: [[type: "text", text: mensajeJira]]]]]
              ])
              writeFile file: 'comentario.json', text: comentario
              sh """curl -s -u "$JIRA_USER:$JIRA_API_TOKEN" -X POST -H "Content-Type: application/json" --data @comentario.json "${JIRA_API_URL}${params.TICKET_JIRA}/comment" """
              echo "Ticket ${params.TICKET_JIRA} transicionado a Done."
            } else if (estado in ["Done", "Finalizado"]) {
              error("El ticket ${params.TICKET_JIRA} ya está '${estado}'.")
            } else {
              def mensajeError = "Ticket ${params.TICKET_JIRA} no elegible. Estado actual: '${estado}'."
              echo mensajeError
              def comentarioError = groovy.json.JsonOutput.toJson([
                body: [type: "doc", version: 1, content: [[type: "paragraph", content: [[type: "text", text: mensajeError]]]]]
              ])
              writeFile file: 'comentario_error.json', text: comentarioError
              sh """curl -s -u "$JIRA_USER:$JIRA_API_TOKEN" -X POST -H "Content-Type: application/json" --data @comentario_error.json "${JIRA_API_URL}${params.TICKET_JIRA}/comment" """
              error("Estado del ticket no permitido.")
            }
          }
        }
      }
    }

    // 2) Notificar a Teams
    stage('Notificar a Teams') {
      steps {
        script {
          if (env.ESTADO_TICKET in ["Done", "Finalizado"]) {
            // Usar el valor efectivo (si ya fue calculado), o lo declarado por parámetro
            def backupEfectivo = env.BACKUP_EFFECTIVE?.trim() ? env.BACKUP_EFFECTIVE : params.DB_BACKUP_ENABLED
            def mensaje = "Ticket ${params.TICKET_JIRA} transicionado a Done.\n\nPipeline en curso."
            def facts = [
              [ name: "País", value: env.PAIS ?: "" ],
              [ name: "Ambiente", value: params.ENVIRONMENT ?: "" ],
              [ name: "Base de Datos", value: "${env.DB_ENGINE} (${params.DB_VERSION})".toString() ],
              [ name: "Proyecto GCP", value: params.PROJECT_ID ?: "" ],
              [ name: "Instancia", value: params.DB_INSTANCE_NAME ?: "" ],
              [ name: "Región/Zona", value: "${params.REGION}/${params.ZONE}" ],
              [ name: "Tipo de Máquina", value: params.MACHINE_TYPE ?: "" ],
              [ name: "Almacenamiento", value: "${params.DB_STORAGE_SIZE} GB (${params.DB_STORAGE_TYPE})" ],
              [ name: "Backup (efectivo)", value: backupEfectivo ?: "" ]
            ]
            def card = [
              '@type': 'MessageCard',
              '@context': 'http://schema.org/extensions',
              text: mensaje,
              summary: "Instancia ${env.DB_ENGINE}",
              themeColor: "0076D7",
              sections: [[
                activitySubtitle: "Ticket Jira: ${params.TICKET_JIRA}",
                facts: facts,
                markdown: true
              ]],
              potentialAction: [[
                '@type': "OpenUri",
                name: "Ver Build",
                targets: [[ os: "default", uri: env.BUILD_URL ?: "" ]]
              ]]
            ]
            def payload = groovy.json.JsonOutput.toJson(card)
            writeFile file: 'teams.json', text: payload
            sh "curl -s -X POST -H 'Content-Type: application/json' --data @teams.json ${TEAMS_WEBHOOK}"
            echo "Notificación enviada a Teams."
          }
        }
      }
    }

    // 3) Validación de variables
    stage('Validación de variables') {
      steps {
        script {
          echo "Validando el ambiente: ${params.ENVIRONMENT}"
          def backupEfectivo = params.DB_BACKUP_ENABLED

          if (params.ENVIRONMENT == 'Produccion') {
            if (params.DB_BACKUP_ENABLED == 'false') {
              echo "Producción detectada. Se fuerza DB_BACKUP_ENABLED = 'true'."
              backupEfectivo = 'true'
            } else {
              echo "Producción OK: DB_BACKUP_ENABLED ya es 'true'."
            }
          } else if (params.ENVIRONMENT in ['Desarrollo', 'Pre-productivo (PP)']) {
            echo "No producción. Se respeta DB_BACKUP_ENABLED=${params.DB_BACKUP_ENABLED}"
          } else {
            error("Ambiente inválido: ${params.ENVIRONMENT}")
          }

          // Publicar el valor efectivo para otros stages
          env.BACKUP_EFFECTIVE = backupEfectivo
        }
      }
    }

    // 4) Crear Infraestructura en GCP
    stage('Crear Infraestructura en GCP') {
      steps {
        script {
          def attempt = 0
          def success = false
          while (attempt < env.MAX_RETRIES.toInteger() && !success) {
            attempt++
            echo "Intento #${attempt}: aprovisionando infraestructura..."
            try {
              // Coloca aquí tu aprovisionamiento real:
              // - Terraform (init/plan/apply)
              // - o gcloud sql instances create ...
              sh 'false' // Simulación de fallo para probar reintentos
              success = true
            } catch (err) {
              echo "Error en intento #${attempt}: ${err.getMessage()}"
              if (attempt == env.MAX_RETRIES.toInteger()) {
                error "Fallo tras ${env.MAX_RETRIES} intentos."
              } else {
                echo "Reintentando..."
              }
            }
          }
        }
      }
    }

    // 5) descripción jira
    stage('descripción Jira') {
      steps {
        script {
          def backupEfectivo = env.BACKUP_EFFECTIVE?.trim() ? env.BACKUP_EFFECTIVE : params.DB_BACKUP_ENABLED
          def notificationText = """
          País : ${env.PAIS}
          Instancia: ${params.DB_INSTANCE_NAME ?: 'N/A'}
          Ambiente: ${params.ENVIRONMENT}
          Proyecto GCP: ${params.PROJECT_ID}
          Región/Zona: ${params.REGION} / ${params.ZONE}

          Base de datos:
          - Motor: ${env.DB_ENGINE}
          - Versión: ${params.DB_VERSION}
          - Usuario: ${params.DB_USERNAME}
          - Máx conexiones: ${params.DB_MAX_CONNECTIONS}
          - Licenciamiento: ${params.DB_SQL_SERVER_LICENSE_MODEL}

          Recursos:
          - Máquina: ${params.MACHINE_TYPE}
          - Almacenamiento: ${params.DB_STORAGE_SIZE} GB (${params.DB_STORAGE_TYPE})
          - Auto-resize: ${params.DB_STORAGE_AUTO_RESIZE}

          Red y acceso:
          - VPC/Subnet: ${params.DB_VPC_NETWORK} / ${params.DB_SUBNET}
          - IP Privada: ${params.DB_PRIVATE_IP_ENABLED}
          - Acceso Público: ${params.DB_PUBLIC_ACCESS_ENABLED}
          - SSL: ${params.DB_SSL_ENABLED}

          Seguridad:
          - Encriptación: ${params.DB_ENCRYPTION_ENABLED}
          - Protección eliminación: ${params.DB_DELETION_PROTECTION}
          - IAM Role: ${params.DB_IAM_ROLE}

          Backup / Mantenimiento:
          - BACKUP Habilitado (efectivo): ${backupEfectivo}
          - Retención (días): ${params.DB_BACKUP_RETENTION_DAYS}
          - Backup start: ${params.DB_BACKUP_START_TIME}
          - Ventana mantención: ${params.DB_MAINTENANCE_WINDOW_DAY} ${params.DB_MAINTENANCE_WINDOW_HOUR}

          Alta disponibilidad / Monitoreo:
          - Monitoring: ${params.DB_MONITORING_ENABLED}
          - Caché habilitado: ${params.ENABLE_CACHE}
          """
          env.mensaje = notificationText
        }
      }
    }

    // 6) crear ticket en jira (solo en Producción)
    stage('Crear ticket en Jira') {
      when { expression { params.ENVIRONMENT == 'Produccion' } }
      steps {
        script {
          withCredentials([usernamePassword(credentialsId: 'JIRA_TOKEN', usernameVariable: 'JIRA_USER', passwordVariable: 'JIRA_API_TOKEN')]) {
            def auth = "${JIRA_USER}:${JIRA_API_TOKEN}".bytes.encodeBase64().toString()
            def payloadMap = [
              fields: [
                project: [ key: env.PROYECT_JIRA ],
                summary: env.TITULO_JIRA,
                description: [
                  type: "doc", version: 1,
                  content: [[
                    type: "paragraph",
                    content: [
                      [ type: "text", text: env.mensaje ?: "Descripción no disponible" ],
                      [ type: "text", text: " | Ver Build", marks: [[ type: "link", attrs: [ href: "${env.BUILD_URL}" ] ]] ]
                    ]
                  ]]
                ],
                issuetype: [ id: env.ID_ISSUETYPE_JIRA ]
              ]
            ]
            def payloadJson = groovy.json.JsonOutput.toJson(payloadMap)
            writeFile file: 'jira_create.json', text: payloadJson
            def response = sh(
              script: """
                curl -s -X POST "${JIRA_API_URL}" \
                -H "Authorization: Basic ${auth}" \
                -H "Content-Type: application/json" \
                --data @jira_create.json
              """,
              returnStdout: true
            ).trim()
            echo "Ticket creado/respuesta: ${response}"
          }
        }
      }
    }

    // 7) Imprimir variables por sección
    stage('Imprimir variables por sección') {
      steps {
        script {
          def backupEfectivo = env.BACKUP_EFFECTIVE?.trim() ? env.BACKUP_EFFECTIVE : params.DB_BACKUP_ENABLED

          def ocultas = [
            DB_ENGINE           : env.DB_ENGINE,
            DB_PASSWORD_ADMIN   : env.DB_PASSWORD_ADMIN,
            DB_PLATFORM_PASS    : env.DB_PLATFORM_PASS,
            DB_PLATFORM_USER    : env.DB_PLATFORM_USER,
            DB_RESOURCE_LABELS  : env.DB_RESOURCE_LABELS,
            DB_SERVICE_PROVIDER : env.DB_SERVICE_PROVIDER,
            DB_TAGS             : env.DB_TAGS,
            DB_TIME_ZONE        : env.DB_TIME_ZONE,
            DB_USER_ADMIN       : env.DB_USER_ADMIN,
            PAIS                : env.PAIS
          ]
          def gcp = [
            ENVIRONMENT : params.ENVIRONMENT,
            PROJECT_ID  : params.PROJECT_ID,
            REGION      : params.REGION,
            ZONE        : params.ZONE
          ]
          def typeInst = [
            DB_AVAILABILITY_TYPE : params.DB_AVAILABILITY_TYPE,
            DB_INSTANCE_ID       : params.DB_INSTANCE_ID,
            DB_INSTANCE_NAME     : params.DB_INSTANCE_NAME,
            DB_MAX_CONNECTIONS   : params.DB_MAX_CONNECTIONS,
            DB_PASSWORD          : params.DB_PASSWORD,
            DB_STORAGE_AUTO_RESIZE: params.DB_STORAGE_AUTO_RESIZE,
            DB_STORAGE_SIZE      : params.DB_STORAGE_SIZE,
            DB_STORAGE_TYPE      : params.DB_STORAGE_TYPE,
            DB_USERNAME          : params.DB_USERNAME,
            DB_VERSION           : params.DB_VERSION,
            MACHINE_TYPE         : params.MACHINE_TYPE,
            DB_SQL_SERVER_LICENSE_MODEL: params.DB_SQL_SERVER_LICENSE_MODEL,
            ENABLE_CACHE         : params.ENABLE_CACHE
          ]
          def redes = [
            DB_IP_RANGE_ALLOWED      : params.DB_IP_RANGE_ALLOWED,
            DB_PRIVATE_IP_ENABLED    : params.DB_PRIVATE_IP_ENABLED,
            DB_PUBLIC_ACCESS_ENABLED : params.DB_PUBLIC_ACCESS_ENABLED,
            DB_SUBNET                : params.DB_SUBNET,
            DB_VPC_NETWORK           : params.DB_VPC_NETWORK,
            DB_SSL_ENABLED           : params.DB_SSL_ENABLED
          ]
          def segOp = [
            DB_BACKUP_ENABLED          : backupEfectivo,
            CHECK_DELETE               : params.CHECK_DELETE,
            CREDENTIAL_FILE            : params.CREDENTIAL_FILE,
            DB_AUDIT_LOGS_ENABLED      : params.DB_AUDIT_LOGS_ENABLED,
            DB_BACKUP_RETENTION_DAYS   : params.DB_BACKUP_RETENTION_DAYS,
            DB_BACKUP_START_TIME       : params.DB_BACKUP_START_TIME,
            DB_DELETION_PROTECTION     : params.DB_DELETION_PROTECTION,
            DB_ENCRYPTION_ENABLED      : params.DB_ENCRYPTION_ENABLED,
            DB_IAM_ROLE                : params.DB_IAM_ROLE,
            DB_MAINTENANCE_WINDOW_DAY  : params.DB_MAINTENANCE_WINDOW_DAY,
            DB_MAINTENANCE_WINDOW_HOUR : params.DB_MAINTENANCE_WINDOW_HOUR,
            DB_MONITORING_ENABLED      : params.DB_MONITORING_ENABLED
          ]
          def replica = [
            DB_FAILOVER_REPLICA_ENABLED: params.DB_FAILOVER_REPLICA_ENABLED,
            DB_READ_REPLICA_ENABLED    : params.DB_READ_REPLICA_ENABLED
          ]

          def printSection = { String titulo, Map m ->
            echo "================= ${titulo} ================="
            def keys = m.keySet().toList(); keys.sort()
            for (k in keys) {
              def v = m[k]
              echo "${k}: ${v == null ? '' : v}"
            }
          }

          printSection('DEFAULT (Ocultas)', ocultas)
          printSection('GCP', gcp)
          printSection('TYPE / INSTANCIA', typeInst)
          printSection('REDES', redes)
          printSection('SEGURIDAD / OPERACIÓN', segOp)
          printSection('REPLICA / FAILOVER', replica)
        }
      }
    }
  }

  post {
    success { echo 'Pipeline ejecutado correctamente.' }
    failure { echo 'Error al ejecutar el pipeline.' }
    always  { echo "==================== FIN DE PIPELINE ====================" }
  }
}
